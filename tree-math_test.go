package mls

import (
	"reflect"
	"testing"
)

// Precomputed answers for the tree on ten elements:
//
//                                              X
//                      X
//          X                       X                       X
//    X           X           X           X           X
// X     X     X     X     X     X     X     X     X     X     X
// 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f 10 11 12 13 14
var (
	aRoot     = []uint{0x00, 0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x0f}
	aFrontier = [][]uint{
		{0x00},
		{0x01},
		{0x01, 0x04},
		{0x03},
		{0x03, 0x08},
		{0x03, 0x09},
		{0x03, 0x09, 0x0c},
		{0x07},
		{0x07, 0x10},
		{0x07, 0x11},
		{0x07, 0x11, 0x14},
	}

	aN       = uint(0x0b)
	index    = []uint{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14}
	aLog2    = []uint{0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04}
	aLevel   = []uint{0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00}
	aLeft    = []uint{0x00, 0x00, 0x02, 0x01, 0x04, 0x04, 0x06, 0x03, 0x08, 0x08, 0x0a, 0x09, 0x0c, 0x0c, 0x0e, 0x07, 0x10, 0x10, 0x12, 0x11, 0x14}
	aRight   = []uint{0x00, 0x02, 0x02, 0x05, 0x04, 0x06, 0x06, 0x0b, 0x08, 0x0a, 0x0a, 0x0d, 0x0c, 0x0e, 0x0e, 0x13, 0x10, 0x12, 0x12, 0x14, 0x14}
	aParent  = []uint{0x01, 0x03, 0x01, 0x07, 0x05, 0x03, 0x05, 0x0f, 0x09, 0x0b, 0x09, 0x07, 0x0d, 0x0b, 0x0d, 0x0f, 0x11, 0x13, 0x11, 0x0f, 0x13}
	aSibling = []uint{0x02, 0x05, 0x00, 0x0b, 0x06, 0x01, 0x04, 0x13, 0x0a, 0x0d, 0x08, 0x03, 0x0e, 0x09, 0x0c, 0x0f, 0x12, 0x14, 0x10, 0x07, 0x11}
	aSubtree = []uint{0x01, 0x02, 0x01, 0x04, 0x01, 0x02, 0x01, 0x08, 0x01, 0x02, 0x01, 0x04, 0x01, 0x02, 0x01, 0x0b, 0x01, 0x02, 0x01, 0x03, 0x01}

	aDirpath = [][]uint{
		{0x07, 0x03, 0x01},
		{0x07, 0x03},
		{0x07, 0x03, 0x01},
		{0x07},
		{0x07, 0x03, 0x05},
		{0x07, 0x03},
		{0x07, 0x03, 0x05},
		{},
		{0x07, 0x0b, 0x09},
		{0x07, 0x0b},
		{0x07, 0x0b, 0x09},
		{0x07},
		{0x07, 0x0b, 0x0d},
		{0x07, 0x0b},
		{0x07, 0x0b, 0x0d},
		{},
		{0x13, 0x11},
		{0x13},
		{0x13, 0x11},
		{},
		{0x13},
	}
	aCopath = [][]uint{
		{0x13, 0x0b, 0x05, 0x02},
		{0x13, 0x0b, 0x05},
		{0x13, 0x0b, 0x05, 0x00},
		{0x13, 0x0b},
		{0x13, 0x0b, 0x01, 0x06},
		{0x13, 0x0b, 0x01},
		{0x13, 0x0b, 0x01, 0x04},
		{0x13},
		{0x13, 0x03, 0x0d, 0x0a},
		{0x13, 0x03, 0x0d},
		{0x13, 0x03, 0x0d, 0x08},
		{0x13, 0x03},
		{0x13, 0x03, 0x09, 0x0e},
		{0x13, 0x03, 0x09},
		{0x13, 0x03, 0x09, 0x0c},
		{},
		{0x07, 0x14, 0x12},
		{0x07, 0x14},
		{0x07, 0x14, 0x10},
		{0x07},
		{0x07, 0x11},
	}
)

func TestSizeProperties(t *testing.T) {
	for n := uint(1); n < aN; n += 1 {
		if root(n) != aRoot[n-1] {
			t.Fatalf("Root mismatch: %v != %v", root(n), aRoot[n-1])
		}

		if !reflect.DeepEqual(frontier(n), aFrontier[n-1]) {
			t.Fatalf("Frontier mismatch: %v != %v", frontier(n), aFrontier[n-1])
		}
	}
}

func TestNodeRelations(t *testing.T) {
	run := func(label string, f func(x uint) uint, a []uint) {
		for i, x := range index {
			if f(x) != a[i] {
				t.Fatalf("Relation test failure: %s @ 0x%02x: %v != %v", label, x, f(x), a[i])
			}
		}
	}

	run("log2", log2, aLog2)
	run("level", level, aLevel)
	run("left", left, aLeft)
	run("right", func(x uint) uint { return right(x, aN) }, aRight)
	run("parent", func(x uint) uint { return parent(x, aN) }, aParent)
	run("sibling", func(x uint) uint { return sibling(x, aN) }, aSibling)
	run("subtreeSize", func(x uint) uint { return subtreeSize(x, aN) }, aSubtree)
}

func TestPaths(t *testing.T) {
	run := func(label string, f func(x uint, n uint) []uint, a [][]uint) {
		for i, x := range index {
			if !reflect.DeepEqual(f(x, aN), a[i]) {
				t.Fatalf("Path test failure: %s @ 0x%02x: %v != %v", label, x, f(x, aN), a[i])
			}
		}
	}

	run("dirpath", dirpath, aDirpath)
	run("copath", copath, aCopath)
}
